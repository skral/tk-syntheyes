# Copyright (c) 2013 Shotgun Software Inc.
#
# CONFIDENTIAL AND PROPRIETARY
#
# This work is provided "AS IS" and subject to the Shotgun Pipeline Toolkit
# Source Code License included in this distribution package. See LICENSE.
# By accessing, using, copying or modifying this work you indicate your
# agreement to the Shotgun Pipeline Toolkit Source Code License. All rights
# not expressly granted therein are reserved by Shotgun Software Inc.

import os

from tank import Hook
from syntheyes import get_existing_connection

from arch.path import Sequence


def get_contexts(context, result=None):
    """
    Returns all the subcontexts of the given context recursively
    """
    if result is None:
        result = []

    result.append(context)
    subcontext_count = context.get_context_count()
    for i in range(subcontext_count):
        subcontext = context.get_context(i)
        get_contexts(subcontext, result=result)

    return result


class BreakdownSceneOperations(Hook):
    """
    Breakdown operations for SynthEyes.
    This implementation handles detection of clarisse file geometric,
    alembic, usd and texture nodes.
    """
    Shot = "shot"
    Mesh = "mesh"
    Texture = "texture"

    def scan_scene(self):
        """
        The scan scene method is executed once at startup and its purpose is
        to analyze the current scene and return a list of references that are
        to be potentially operated on.
        The return data structure is a list of dictionaries. Each scene
        reference that is returned should be represented by a dictionary with
        three keys:
        - "attr": The filename attribute of the 'node' that is to be operated
           on. Most DCCs have a concept of a node, attribute, path or some other
           way to address a particular object in the scene.
        - "type": The object type that this is. This is later passed to the
           update method so that it knows how to handle the object.
        - "path": Path on disk to the referenced object.
        Toolkit will scan the list of items, see if any of the objects matches
        any templates and try to determine if there is a more recent version
        available. Any such versions are then displayed in the UI as out of
        date.
        """
        refs = []
        connection = get_existing_connection()

        shots = connection.Shots()
        if shots:
            for shot in shots:
                image_path = shot.imageName
                sequences = Sequence.sequences_from_directory(os.path.dirname(image_path))
                _frame = shot.frameFirstOffset + connection.Frame()
                for sequence in sequences:
                    if sequence[_frame] == image_path:
                        pattern = os.path.join(os.path.dirname(sequence[sequence.first_frame]), sequence.pattern)
                        refs.append(
                            {
                                "attr": shot,
                                "type": BreakdownSceneOperations.Shot,
                                "path": pattern,
                                "node": shot
                            }
                        )

        meshes = connection.Meshes()
        if meshes:
            for mesh in meshes:
                geo_path = mesh.file()
                if geo_path:
                    refs.append(
                        {
                            "attr": mesh,
                            "type": BreakdownSceneOperations.Mesh,
                            "path": geo_path,
                            "node": mesh
                        }
                    )
                texture_path = mesh.txFilename()
                if texture_path:
                    refs.append(
                        {
                            "attr": mesh,
                            "type": BreakdownSceneOperations.Texture,
                            "path": texture_path,
                            "node": mesh
                        }
                    )

        return refs

    def update(self, items):
        """
        Perform replacements given a number of scene items passed from the app.
        Once a selection has been performed in the main UI and the user clicks
        the update button, this method is called.
        The items parameter is a list of dictionaries on the same form as was
        generated by the scan_scene hook above. The path key now holds
        the that each attribute should be updated *to* rather than the current
        path.
        """
        connection = get_existing_connection()
        engine = self.parent.engine

        for i in items:
            node = i["node"]
            node_type = i["type"]
            new_path = i["path"]

            if node_type == BreakdownSceneOperations.Shot:
                engine.log_debug(
                    "%s %s: Updating to version %s" % (node_type, node, new_path)
                )
                print("new_path: %s" % new_path)
                sequence = Sequence.sequence_from_pattern(new_path)
                node.nm = new_path
                node.Flush()
                node.frameCount = len(sequence.frames)
                node.start = sequence.first_frame
                node.stop = sequence.last_frame

            elif node_type == BreakdownSceneOperations.Mesh:
                engine.log_debug(
                    "%s %s: Updating to version %s" % (node_type, node, new_path)
                )
                node.ReadOBJ(new_path)

            elif node_type == BreakdownSceneOperations.Texture:
                engine.log_debug(
                    "%s %s: Updating to version %s" % (node_type, node, new_path)
                )
                scene = connection.Scene()
                image = scene.ReadImage()
                node.txImage = image
